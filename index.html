<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé® PCA AI Checker - Real vs AI Image Detection</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-gray-400: rgba(119, 124, 124, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-brown-600: rgba(94, 82, 64, 1);
            --color-charcoal-700: rgba(31, 33, 33, 1);
            --color-charcoal-800: rgba(38, 40, 40, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-400: rgba(45, 166, 178, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-teal-800: rgba(41, 150, 161, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-400: rgba(230, 129, 97, 1);
            --color-orange-500: rgba(168, 75, 47, 1);

            --color-brown-600-rgb: 94, 82, 64;
            --color-teal-500-rgb: 33, 128, 141;
            --color-slate-900-rgb: 19, 52, 59;
            --color-slate-500-rgb: 98, 108, 113;
            --color-red-500-rgb: 192, 21, 47;
            --color-red-400-rgb: 255, 84, 89;
            --color-orange-500-rgb: 168, 75, 47;
            --color-orange-400-rgb: 230, 129, 97;

            --color-bg-1: rgba(59, 130, 246, 0.08);
            --color-bg-2: rgba(245, 158, 11, 0.08);
            --color-bg-3: rgba(34, 197, 94, 0.08);
            --color-bg-4: rgba(239, 68, 68, 0.08);
            --color-bg-5: rgba(147, 51, 234, 0.08);
            --color-bg-6: rgba(249, 115, 22, 0.08);
            --color-bg-7: rgba(236, 72, 153, 0.08);
            --color-bg-8: rgba(6, 182, 212, 0.08);

            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-secondary: rgba(var(--color-brown-600-rgb), 0.12);
            --color-secondary-hover: rgba(var(--color-brown-600-rgb), 0.2);
            --color-secondary-active: rgba(var(--color-brown-600-rgb), 0.25);
            --color-border: rgba(var(--color-brown-600-rgb), 0.2);
            --color-btn-primary-text: var(--color-cream-50);
            --color-card-border: rgba(var(--color-brown-600-rgb), 0.12);
            --color-card-border-inner: rgba(var(--color-brown-600-rgb), 0.12);
            --color-error: var(--color-red-500);
            --color-success: var(--color-teal-500);
            --color-warning: var(--color-orange-500);
            --color-info: var(--color-slate-500);
            --color-focus-ring: rgba(var(--color-teal-500-rgb), 0.4);
            --color-select-caret: rgba(var(--color-slate-900-rgb), 0.8);

            --focus-ring: 0 0 0 3px var(--color-focus-ring);
            --focus-outline: 2px solid var(--color-primary);
            --status-bg-opacity: 0.15;
            --status-border-opacity: 0.25;

            --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-family-mono: 'Monaco', 'Courier New', monospace;
            --font-size-xs: 11px;
            --font-size-sm: 12px;
            --font-size-base: 14px;
            --font-size-md: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --font-size-4xl: 30px;
            --font-weight-normal: 400;
            --font-weight-medium: 500;
            --font-weight-semibold: 550;
            --font-weight-bold: 600;
            --line-height-tight: 1.2;
            --line-height-normal: 1.5;
            --letter-spacing-tight: -0.01em;

            --space-0: 0;
            --space-1: 1px;
            --space-2: 2px;
            --space-4: 4px;
            --space-6: 6px;
            --space-8: 8px;
            --space-10: 10px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;

            --radius-sm: 6px;
            --radius-base: 8px;
            --radius-md: 10px;
            --radius-lg: 12px;
            --radius-full: 9999px;

            --shadow-xs: 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
            --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.04), 0 4px 6px -2px rgba(0, 0, 0, 0.02);

            --duration-fast: 150ms;
            --duration-normal: 250ms;
            --ease-standard: cubic-bezier(0.16, 1, 0.3, 1);
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --color-background: var(--color-charcoal-700);
                --color-surface: var(--color-charcoal-800);
                --color-text: var(--color-gray-200);
                --color-text-secondary: rgba(167, 169, 169, 0.7);
                --color-primary: var(--color-teal-300);
                --color-primary-hover: var(--color-teal-400);
                --color-primary-active: var(--color-teal-800);
                --color-secondary: rgba(119, 124, 124, 0.15);
                --color-secondary-hover: rgba(119, 124, 124, 0.25);
                --color-secondary-active: rgba(119, 124, 124, 0.3);
                --color-border: rgba(119, 124, 124, 0.3);
                --color-error: var(--color-red-400);
                --color-success: var(--color-teal-300);
                --color-warning: var(--color-orange-400);
                --color-info: var(--color-gray-300);
                --color-btn-primary-text: var(--color-slate-900);
                --color-card-border: rgba(119, 124, 124, 0.2);
                --color-card-border-inner: rgba(119, 124, 124, 0.15);
            }
        }

        * {
            box-sizing: border-box;
        }

        html {
            font-size: var(--font-size-base);
            font-family: var(--font-family-base);
            line-height: var(--line-height-normal);
            color: var(--color-text);
            background-color: var(--color-background);
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            padding: var(--space-20);
            max-width: 1200px;
            margin: 0 auto;
        }

        h1, h2, h3 {
            margin: 0 0 var(--space-16) 0;
            font-weight: var(--font-weight-semibold);
            line-height: var(--line-height-tight);
        }

        h1 {
            font-size: var(--font-size-3xl);
        }

        h2 {
            font-size: var(--font-size-2xl);
        }

        h3 {
            font-size: var(--font-size-xl);
        }

        p {
            margin: 0 0 var(--space-16) 0;
        }

        a {
            color: var(--color-primary);
            text-decoration: none;
            transition: color var(--duration-fast) var(--ease-standard);
        }

        a:hover {
            color: var(--color-primary-hover);
        }

        input[type="text"],
        input[type="password"],
        input[type="file"],
        input[type="range"],
        textarea,
        select {
            font-family: var(--font-family-base);
            font-size: var(--font-size-base);
            padding: var(--space-8) var(--space-12);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            background-color: var(--color-surface);
            color: var(--color-text);
            transition: border-color var(--duration-fast), box-shadow var(--duration-fast);
        }

        input[type="range"] {
            padding: 0;
            height: 6px;
            cursor: pointer;
        }

        input[type="text"]:focus,
        input[type="password"]:focus,
        textarea:focus,
        select:focus {
            border-color: var(--color-primary);
            outline: var(--focus-outline);
            box-shadow: var(--focus-ring);
        }

        button, .button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-8) var(--space-16);
            border-radius: var(--radius-base);
            font-size: var(--font-size-base);
            font-weight: 500;
            cursor: pointer;
            transition: all var(--duration-normal) var(--ease-standard);
            border: none;
            text-decoration: none;
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
        }

        button:hover, .button:hover {
            background: var(--color-primary-hover);
        }

        button:active, .button:active {
            background: var(--color-primary-active);
        }

        button:focus-visible, .button:focus-visible {
            outline: none;
            box-shadow: var(--focus-ring);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .button-secondary {
            background: var(--color-secondary);
            color: var(--color-text);
        }

        .button-secondary:hover {
            background: var(--color-secondary-hover);
        }

        .card {
            background-color: var(--color-surface);
            border-radius: var(--radius-lg);
            border: 1px solid var(--color-card-border);
            box-shadow: var(--shadow-sm);
            padding: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .flex {
            display: flex;
            gap: var(--space-16);
            align-items: center;
        }

        .flex-col {
            flex-direction: column;
        }

        .form-group {
            margin-bottom: var(--space-16);
        }

        .form-group label {
            display: block;
            margin-bottom: var(--space-8);
            font-weight: var(--font-weight-medium);
            font-size: var(--font-size-sm);
        }

        .form-group small {
            display: block;
            color: var(--color-text-secondary);
            font-size: var(--font-size-xs);
            margin-top: var(--space-4);
        }

        .status {
            display: inline-block;
            padding: var(--space-6) var(--space-12);
            border-radius: var(--radius-full);
            font-weight: var(--font-weight-medium);
            font-size: var(--font-size-sm);
        }

        .status-success {
            background-color: rgba(var(--color-teal-500-rgb), 0.15);
            color: var(--color-success);
            border: 1px solid rgba(var(--color-teal-500-rgb), 0.25);
        }

        .status-error {
            background-color: rgba(var(--color-red-500-rgb), 0.15);
            color: var(--color-error);
            border: 1px solid rgba(var(--color-red-500-rgb), 0.25);
        }

        .status-warning {
            background-color: rgba(var(--color-orange-500-rgb), 0.15);
            color: var(--color-warning);
            border: 1px solid rgba(var(--color-orange-500-rgb), 0.25);
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
            margin-bottom: var(--space-24);
        }

        canvas {
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            background: var(--color-surface);
            max-width: 100%;
            height: auto;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
            margin-bottom: var(--space-24);
        }

        @media (max-width: 768px) {
            .container {
                grid-template-columns: 1fr;
            }

            .results-grid {
                grid-template-columns: 1fr;
            }

            body {
                padding: var(--space-12);
            }
        }

        details {
            margin-bottom: var(--space-24);
        }

        details summary {
            cursor: pointer;
            font-weight: 600;
            font-size: var(--font-size-lg);
            color: var(--color-text);
            padding: var(--space-16);
            background: var(--color-secondary);
            border-radius: var(--radius-base);
            user-select: none;
        }

        details summary:hover {
            background: var(--color-secondary-hover);
        }

        details[open] summary {
            background: var(--color-secondary-hover);
        }

        .settings-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: var(--space-16);
            margin-top: var(--space-16);
        }

        .setting-item {
            display: flex;
            flex-direction: column;
            gap: var(--space-8);
        }

        .setting-item label {
            font-weight: var(--font-weight-medium);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .setting-value {
            background: var(--color-primary);
            color: var(--color-btn-primary-text);
            padding: var(--space-2) var(--space-8);
            border-radius: var(--radius-sm);
            font-size: var(--font-size-sm);
            font-weight: var(--font-weight-bold);
        }

        .feature-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        .feature-list li {
            padding: var(--space-8) 0;
            border-bottom: 1px solid var(--color-border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .feature-list li:last-child {
            border-bottom: none;
        }

        .feature-value {
            font-weight: var(--font-weight-semibold);
            color: var(--color-primary);
        }

        .loading {
            display: inline-block;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .header {
            text-align: center;
            margin-bottom: var(--space-32);
        }

        .subtitle {
            font-size: var(--font-size-lg);
            color: var(--color-text-secondary);
            margin: 0 0 var(--space-16) 0;
        }

        .divider {
            height: 1px;
            background: var(--color-border);
            margin: var(--space-24) 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üé® PCA AI Checker</h1>
        <p class="subtitle">Works on ANY imagery - photos, art, medical scans, screenshots, and more. Detect real vs AI using PCA + Grok AI.</p>
    </div>

    <div class="card">
        <h2>üì• Step 1: Upload Images</h2>
        <div class="grid">
            <div class="form-group">
                <label for="referenceImage">Reference Image (Known Real)</label>
                <input type="file" id="referenceImage" accept="image/*" />
                <canvas id="refCanvas" style="display: none;"></canvas>
                <div id="refPreview" style="margin-top: var(--space-12); max-height: 200px; border-radius: var(--radius-base); overflow: hidden;"></div>
            </div>
            <div class="form-group">
                <label for="testImage">Test Image (To Analyze)</label>
                <input type="file" id="testImage" accept="image/*" />
                <canvas id="testCanvas" style="display: none;"></canvas>
                <div id="testPreview" style="margin-top: var(--space-12); max-height: 200px; border-radius: var(--radius-base); overflow: hidden;"></div>
            </div>
        </div>
    </div>

    <div class="card">
        <h2>üîë Step 2: Configure Grok API</h2>
        <div class="form-group">
            <label for="apiKey">Grok API Key</label>
            <input type="password" id="apiKey" placeholder="xai-..." />
            <small>Get free API key at <a href="https://docs.x.ai/docs/api-reference#chat-completions" target="_blank">Grok API Documentation</a></small>
        </div>
        <button onclick="testGrokAPI()">üß™ Test API Connection</button>
        <div id="apiStatus" style="margin-top: var(--space-12);"></div>
    </div>

    <div class="card">
        <details>
            <summary>‚öôÔ∏è PCA Advanced Settings</summary>
            <div class="settings-grid">
                <div class="setting-item">
                    <label>
                        Patch Size
                        <span class="setting-value" id="patchSizeDisplay">8</span>
                    </label>
                    <input type="range" id="patchSize" min="4" max="16" value="8" />
                    <small>4 = more detail (slower) | 16 = faster (less detail)</small>
                </div>

                <div class="setting-item">
                    <label>
                        Power Iterations
                        <span class="setting-value" id="iterationsDisplay">20</span>
                    </label>
                    <input type="range" id="powerIterations" min="10" max="50" value="20" />
                    <small>10 = faster | 50 = more accurate eigenvectors</small>
                </div>

                <div class="setting-item">
                    <label>
                        Canvas Size
                        <span class="setting-value" id="canvasSizeDisplay">300px</span>
                    </label>
                    <input type="range" id="canvasSize" min="200" max="400" value="300" />
                    <small>200 = faster | 400 = more detail</small>
                </div>

                <div class="setting-item">
                    <label>
                        Classification Threshold
                        <span class="setting-value" id="thresholdDisplay">0.5</span>
                    </label>
                    <input type="range" id="classificationThreshold" min="0.3" max="0.7" step="0.1" value="0.5" />
                    <small>0.3 = more sensitive to AI | 0.7 = more sensitive to real</small>
                </div>
            </div>
            <button class="button-secondary" onclick="resetPCASettings()" style="margin-top: var(--space-16); width: 100%;">‚Üª Reset to Defaults</button>
        </details>
    </div>

    <div class="card">
        <button onclick="analyzeImages()" style="width: 100%; padding: var(--space-12); font-size: var(--font-size-lg);">üîç Analyze Images</button>
        <div id="analysisStatus" style="margin-top: var(--space-12);"></div>
    </div>

    <div id="resultsContainer"></div>

    <script>
        // PCA Settings
        let pcaSettings = {
            patchSize: 8,
            powerIterations: 20,
            canvasSize: 300,
            classificationThreshold: 0.5
        };

        // Update display when sliders change
        document.getElementById('patchSize')?.addEventListener('input', (e) => {
            pcaSettings.patchSize = parseInt(e.target.value);
            document.getElementById('patchSizeDisplay').textContent = e.target.value;
        });

        document.getElementById('powerIterations')?.addEventListener('input', (e) => {
            pcaSettings.powerIterations = parseInt(e.target.value);
            document.getElementById('iterationsDisplay').textContent = e.target.value;
        });

        document.getElementById('canvasSize')?.addEventListener('input', (e) => {
            pcaSettings.canvasSize = parseInt(e.target.value);
            document.getElementById('canvasSizeDisplay').textContent = e.target.value + 'px';
        });

        document.getElementById('classificationThreshold')?.addEventListener('input', (e) => {
            pcaSettings.classificationThreshold = parseFloat(e.target.value);
            document.getElementById('thresholdDisplay').textContent = e.target.value;
        });

        function resetPCASettings() {
            pcaSettings = { patchSize: 8, powerIterations: 20, canvasSize: 300, classificationThreshold: 0.5 };
            document.getElementById('patchSize').value = 8;
            document.getElementById('powerIterations').value = 20;
            document.getElementById('canvasSize').value = 300;
            document.getElementById('classificationThreshold').value = 0.5;
            document.getElementById('patchSizeDisplay').textContent = '8';
            document.getElementById('iterationsDisplay').textContent = '20';
            document.getElementById('canvasSizeDisplay').textContent = '300px';
            document.getElementById('thresholdDisplay').textContent = '0.5';
        }

        // File upload handlers
        document.getElementById('referenceImage').addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('refCanvas');
                    canvas.width = pcaSettings.canvasSize;
                    canvas.height = pcaSettings.canvasSize;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    displayPreview(evt.target.result, 'refPreview');
                };
                img.src = evt.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        document.getElementById('testImage').addEventListener('change', (e) => {
            const reader = new FileReader();
            reader.onload = (evt) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.getElementById('testCanvas');
                    canvas.width = pcaSettings.canvasSize;
                    canvas.height = pcaSettings.canvasSize;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    displayPreview(evt.target.result, 'testPreview');
                };
                img.src = evt.target.result;
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        function displayPreview(src, previewId) {
            const preview = document.getElementById(previewId);
            preview.innerHTML = `<img src="${src}" style="width: 100%; height: 100%; object-fit: cover; border-radius: var(--radius-base);" />`;
        }

        async function testGrokAPI() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const status = document.getElementById('apiStatus');

            if (!apiKey) {
                status.innerHTML = '<span class="status status-error">‚ùå Please paste API key</span>';
                return;
            }

            status.innerHTML = '<span class="status status-warning">‚è≥ Testing...</span>';

            try {
                const response = await fetch('https://api.x.ai/openai/', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'grok-vision-beta',
                        messages: [{
                            role: 'user',
                            content: 'test'
                        }],
                        max_tokens: 10
                    })
                });

                if (response.status === 200) {
                    status.innerHTML = '<span class="status status-success">‚úÖ API key valid!</span>';
                } else if (response.status === 401) {
                    status.innerHTML = '<span class="status status-error">‚ùå Invalid API key</span>';
                } else {
                    status.innerHTML = '<span class="status status-error">‚ùå Error: ' + response.status + '</span>';
                }
            } catch (e) {
                status.innerHTML = '<span class="status status-warning">‚ö†Ô∏è Cannot verify offline (will try on analyze)</span>';
            }
        }

        function imageToPatchVectors(imageData, patchSize) {
            const { data, width, height } = imageData;
            const patches = [];

            for (let y = 0; y <= height - patchSize; y += patchSize) {
                for (let x = 0; x <= width - patchSize; x += patchSize) {
                    const patch = [];
                    for (let py = 0; py < patchSize; py++) {
                        for (let px = 0; px < patchSize; px++) {
                            const idx = ((y + py) * width + (x + px)) * 4;
                            const r = data[idx] || 0;
                            const g = data[idx + 1] || 0;
                            const b = data[idx + 2] || 0;
                            const gray = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
                            patch.push(gray);
                        }
                    }
                    patches.push(patch);
                }
            }

            return patches.length > 0 ? patches : [[0]];
        }

        function computeCovariance(patches) {
            const n = patches.length;
            const dim = patches[0].length;
            const mean = Array(dim).fill(0);

            for (let i = 0; i < n; i++) {
                for (let j = 0; j < dim; j++) {
                    mean[j] += patches[i][j];
                }
            }

            for (let j = 0; j < dim; j++) {
                mean[j] /= n;
            }

            const centered = patches.map(p => p.map((v, i) => v - mean[i]));
            const cov = Array(dim).fill(0).map(() => Array(dim).fill(0));

            for (let i = 0; i < dim; i++) {
                for (let j = i; j < dim; j++) {
                    let sum = 0;
                    for (let k = 0; k < n; k++) {
                        sum += centered[k][i] * centered[k][j];
                    }
                    cov[i][j] = cov[j][i] = sum / (n - 1 || 1);
                }
            }

            return { cov, mean };
        }

        function powerIteration(matrix, numIter = 20) {
            const n = matrix.length;
            let v = Array(n).fill(1).map(() => Math.random());
            let norm = Math.sqrt(v.reduce((a, b) => a + b * b, 0));
            v = v.map(x => x / norm);

            for (let iter = 0; iter < numIter; iter++) {
                const Av = Array(n).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        Av[i] += matrix[i][j] * v[j];
                    }
                }

                norm = Math.sqrt(Av.reduce((a, b) => a + b * b, 0));
                if (norm < 1e-10) break;
                v = Av.map(x => x / norm);
            }

            let eigenvalue = 0;
            for (let i = 0; i < n; i++) {
                let sum = 0;
                for (let j = 0; j < n; j++) {
                    sum += matrix[i][j] * v[j];
                }
                eigenvalue += sum * v[i];
            }

            return { eigenvalue, eigenvector: v };
        }

        function performPCA(patches) {
            const { cov, mean } = computeCovariance(patches);
            const { eigenvalue: lambda1, eigenvector: pc1 } = powerIteration(cov, pcaSettings.powerIterations);

            const covAdjusted = cov.map((row, i) => row.map((v, j) => v - lambda1 * (i === j ? 1 : 0)));
            const { eigenvalue: lambda2, eigenvector: pc2 } = powerIteration(covAdjusted, pcaSettings.powerIterations);

            return { pc1, pc2, lambda1, lambda2 };
        }

        function computeFeatures(imageData) {
            const patches = imageToPatchVectors(imageData, pcaSettings.patchSize);
            const { pc1, pc2, lambda1, lambda2 } = performPCA(patches);

            const coherence = Math.min(1, Math.abs(lambda2 / (lambda1 + 1e-10)));
            const noiseLevel = Math.sqrt(lambda2) * 255;
            const pc1Var = lambda1;

            return { coherence, noiseLevel, pc1Var, pc1, pc2, patches };
        }

        async function analyzeImages() {
            const refCanvas = document.getElementById('refCanvas');
            const testCanvas = document.getElementById('testCanvas');
            const status = document.getElementById('analysisStatus');

            if (!refCanvas.width || !testCanvas.width) {
                status.innerHTML = '<span class="status status-error">‚ùå Please upload both images</span>';
                return;
            }

            status.innerHTML = '<span class="status status-warning"><span class="loading">‚è≥</span> Analyzing...</span>';

            try {
                const refCtx = refCanvas.getContext('2d');
                const testCtx = testCanvas.getContext('2d');
                const refImageData = refCtx.getImageData(0, 0, refCanvas.width, refCanvas.height);
                const testImageData = testCtx.getImageData(0, 0, testCanvas.width, testCanvas.height);

                const refFeatures = computeFeatures(refImageData);
                const testFeatures = computeFeatures(testImageData);

                const coherenceDiff = Math.abs(refFeatures.coherence - testFeatures.coherence);
                const noiseDiff = Math.abs(refFeatures.noiseLevel - testFeatures.noiseLevel) / 255;
                const varianceDiff = Math.abs(refFeatures.pc1Var - testFeatures.pc1Var) / (refFeatures.pc1Var + 1e-10);

                const testScore = (1 - (coherenceDiff + noiseDiff + varianceDiff) / 3);
                const isReal = testScore > pcaSettings.classificationThreshold;
                const confidence = Math.abs(testScore - 0.5) * 2 * 100;

                displayResults(refFeatures, testFeatures, testScore, isReal, confidence);
                status.innerHTML = '<span class="status status-success">‚úÖ Analysis complete</span>';

            } catch (e) {
                status.innerHTML = '<span class="status status-error">‚ùå Error: ' + e.message + '</span>';
                console.error(e);
            }
        }

        function displayResults(refFeatures, testFeatures, testScore, isReal, confidence) {
            const container = document.getElementById('resultsContainer');

            const pcaCanvas1 = drawPCAPlot(refFeatures, 300);
            const pcaCanvas2 = drawPCAPlot(testFeatures, 300);

            let html = `
                <div class="divider"></div>
                <h2>üìä Analysis Results</h2>

                <div class="results-grid">
                    <div>
                        <h3>Reference Image</h3>
                        ${pcaCanvas1.outerHTML}
                    </div>
                    <div>
                        <h3>Test Image</h3>
                        ${pcaCanvas2.outerHTML}
                    </div>
                </div>

                <div class="card">
                    <h3>üéØ Classification</h3>
                    <div style="font-size: var(--font-size-2xl); font-weight: var(--font-weight-bold); margin-bottom: var(--space-16);">
                        <span class="status ${isReal ? 'status-success' : 'status-error'}">
                            ${isReal ? '‚úÖ REAL' : '‚ùå AI GENERATED'}
                        </span>
                    </div>
                    <p>Confidence: <strong>${confidence.toFixed(1)}%</strong></p>
                </div>

                <div class="card">
                    <h3>üìà Feature Analysis</h3>
                    <ul class="feature-list">
                        <li>
                            <span>Coherence (Test)</span>
                            <span class="feature-value">${testFeatures.coherence.toFixed(3)}</span>
                        </li>
                        <li>
                            <span>Noise Level (Test)</span>
                            <span class="feature-value">${testFeatures.noiseLevel.toFixed(1)}</span>
                        </li>
                        <li>
                            <span>PC1 Variance (Test)</span>
                            <span class="feature-value">${testFeatures.pc1Var.toFixed(3)}</span>
                        </li>
                    </ul>
                </div>

                <div class="card">
                    <button onclick="getGrokExplanation('${isReal}', ${testFeatures.coherence.toFixed(3)}, ${testFeatures.noiseLevel.toFixed(1)})">
                        üß† Get Grok Explanation
                    </button>
                </div>

                <div id="grokResults"></div>
            `;

            container.innerHTML = html;
        }

        function drawPCAPlot(features, size) {
            const canvas = document.createElement('canvas');
            canvas.width = size;
            canvas.height = size;
            const ctx = canvas.getContext('2d');

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-surface');
            ctx.fillRect(0, 0, size, size);

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-border');
            ctx.lineWidth = 1;
            ctx.strokeRect(0, 0, size, size);

            const margin = 40;
            const plotSize = size - 2 * margin;

            ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary');
            ctx.beginPath();
            ctx.moveTo(margin, size - margin);
            ctx.lineTo(size - margin, size - margin);
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, size - margin);
            ctx.stroke();

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-primary');
            const pc1 = features.pc1;
            const pc2 = features.pc2;

            for (let i = 0; i < Math.min(pc1.length, pc2.length); i++) {
                const x = margin + ((pc1[i] + 1) / 2) * plotSize;
                const y = size - margin - ((pc2[i] + 1) / 2) * plotSize;

                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--color-text-secondary');
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('PC1', size / 2, size - 10);
            ctx.save();
            ctx.translate(10, size / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('PC2', 0, 0);
            ctx.restore();

            return canvas;
        }

        async function getGrokExplanation(isReal, coherence, noise) {
            const apiKey = document.getElementById('apiKey').value.trim();

            if (!apiKey) {
                document.getElementById('grokResults').innerHTML = '<div class="card"><span class="status status-error">‚ùå Please enter API key first</span></div>';
                return;
            }

            const resultsDiv = document.getElementById('grokResults');
            resultsDiv.innerHTML = '<div class="card"><span class="status status-warning"><span class="loading">‚è≥</span> Getting Grok explanation...</span></div>';

            const refCanvas = document.getElementById('refCanvas');
            const testCanvas = document.getElementById('testCanvas');
            const refBase64 = refCanvas.toDataURL('image/png').split(',')[1];
            const testBase64 = testCanvas.toDataURL('image/png').split(',')[1];

            const prompt = `Analyze these two images for authenticity using the provided PCA metrics. 
Reference image (known real) coherence: ${coherence}, noise level: ${noise}.
The test image appears to be ${isReal ? 'REAL' : 'AI GENERATED'} based on PCA analysis.
Explain the forensic findings, confidence level, and any visible artifacts or characteristics that support this assessment.`;

            try {
                const response = await fetch('https://api.x.ai/openai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${apiKey}`,
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        model: 'grok-vision-beta',
                        messages: [{
                            role: 'user',
                            content: [
                                { type: 'text', text: prompt },
                                { type: 'image_url', image_url: { url: `data:image/png;base64,${refBase64}` } },
                                { type: 'image_url', image_url: { url: `data:image/png;base64,${testBase64}` } }
                            ]
                        }],
                        max_tokens: 500
                    })
                });

                const data = await response.json();

                if (data.choices && data.choices[0] && data.choices[0].message) {
                    const explanation = data.choices[0].message.content;
                    resultsDiv.innerHTML = `
                        <div class="card">
                            <h3>üß† Grok's Analysis</h3>
                            <p>${explanation}</p>
                        </div>
                    `;
                } else {
                    resultsDiv.innerHTML = '<div class="card"><span class="status status-error">‚ùå No response from Grok</span></div>';
                }
            } catch (e) {
                resultsDiv.innerHTML = `<div class="card"><span class="status status-error">‚ùå Error: ${e.message}</span></div>`;
                console.error(e);
            }
        }
    </script>
</body>
</html>
