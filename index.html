<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satellite Real vs AI Image Detector</title>
    <style>
        :root {
            --color-white: rgba(255, 255, 255, 1);
            --color-cream-50: rgba(252, 252, 249, 1);
            --color-cream-100: rgba(255, 255, 253, 1);
            --color-gray-200: rgba(245, 245, 245, 1);
            --color-gray-300: rgba(167, 169, 169, 1);
            --color-slate-500: rgba(98, 108, 113, 1);
            --color-slate-900: rgba(19, 52, 59, 1);
            --color-teal-300: rgba(50, 184, 198, 1);
            --color-teal-500: rgba(33, 128, 141, 1);
            --color-teal-600: rgba(29, 116, 128, 1);
            --color-teal-700: rgba(26, 104, 115, 1);
            --color-red-400: rgba(255, 84, 89, 1);
            --color-red-500: rgba(192, 21, 47, 1);
            --color-orange-400: rgba(230, 129, 97, 1);
            --color-background: var(--color-cream-50);
            --color-surface: var(--color-cream-100);
            --color-text: var(--color-slate-900);
            --color-text-secondary: var(--color-slate-500);
            --color-primary: var(--color-teal-500);
            --color-primary-hover: var(--color-teal-600);
            --color-primary-active: var(--color-teal-700);
            --color-border: rgba(94, 82, 64, 0.2);
            --color-success: var(--color-teal-500);
            --color-error: var(--color-red-500);
            --color-warning: var(--color-orange-400);
            --font-family-base: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            --font-size-base: 14px;
            --font-size-lg: 16px;
            --font-size-xl: 18px;
            --font-size-2xl: 20px;
            --font-size-3xl: 24px;
            --space-8: 8px;
            --space-12: 12px;
            --space-16: 16px;
            --space-20: 20px;
            --space-24: 24px;
            --space-32: 32px;
            --radius-base: 8px;
            --radius-lg: 12px;
            --shadow-sm: 0 1px 3px rgba(0, 0, 0, 0.04), 0 1px 2px rgba(0, 0, 0, 0.02);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.04), 0 2px 4px -1px rgba(0, 0, 0, 0.02);
        }

        * {
            box-sizing: border-box;
        }

        html {
            font-size: var(--font-size-base);
            font-family: var(--font-family-base);
            color: var(--color-text);
            background-color: var(--color-background);
            -webkit-font-smoothing: antialiased;
        }

        body {
            margin: 0;
            padding: var(--space-20);
            background-color: var(--color-background);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: var(--space-32);
            border-bottom: 2px solid var(--color-border);
            padding-bottom: var(--space-20);
        }

        h1 {
            margin: 0 0 var(--space-8) 0;
            font-size: var(--font-size-3xl);
            color: var(--color-text);
            font-weight: 600;
        }

        .subtitle {
            color: var(--color-text-secondary);
            font-size: var(--font-size-lg);
            margin: 0;
        }

        .api-setup {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .api-input-group {
            display: flex;
            gap: var(--space-12);
            margin-bottom: var(--space-16);
            flex-wrap: wrap;
        }

        .api-input-group input {
            flex: 1;
            min-width: 200px;
            padding: var(--space-8) var(--space-12);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            font-size: var(--font-size-base);
        }

        .upload-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .upload-card {
            background: var(--color-surface);
            border: 2px dashed var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-20);
            text-align: center;
        }

        .upload-card h3 {
            margin: 0 0 var(--space-12) 0;
            font-size: var(--font-size-lg);
            color: var(--color-text);
        }

        .upload-card p {
            margin: 0 0 var(--space-16) 0;
            color: var(--color-text-secondary);
            font-size: var(--font-size-base);
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }

        .file-input-wrapper input[type="file"] {
            display: none;
        }

        .file-input-label {
            display: block;
            padding: var(--space-12) var(--space-20);
            background: var(--color-primary);
            color: white;
            border-radius: var(--radius-base);
            cursor: pointer;
            font-weight: 500;
            transition: background 0.2s;
            text-align: center;
        }

        .file-input-label:hover {
            background: var(--color-primary-hover);
        }

        .preview-image {
            max-width: 100%;
            max-height: 300px;
            margin-top: var(--space-16);
            border-radius: var(--radius-base);
            border: 1px solid var(--color-border);
        }

        .results-section {
            display: none;
        }

        .results-section.active {
            display: block;
        }

        .grid-2x2 {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
            margin-bottom: var(--space-24);
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-20);
        }

        .grid-item {
            text-align: center;
        }

        .grid-item h3 {
            margin: 0 0 var(--space-12) 0;
            font-size: var(--font-size-lg);
            color: var(--color-text);
        }

        .grid-item canvas {
            max-width: 100%;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-base);
            background: white;
        }

        .row-label {
            margin-bottom: var(--space-12);
            font-weight: 600;
            color: var(--color-text-secondary);
            font-size: var(--font-size-base);
        }

        .classification-box {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .classification-result {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: var(--space-20);
        }

        .result-card {
            background: white;
            border: 2px solid var(--color-border);
            border-radius: var(--radius-base);
            padding: var(--space-16);
            text-align: center;
        }

        .result-card.real {
            border-color: var(--color-success);
            background: rgba(33, 128, 141, 0.08);
        }

        .result-card.fake {
            border-color: var(--color-error);
            background: rgba(255, 84, 89, 0.08);
        }

        .badge {
            display: inline-block;
            padding: var(--space-8) var(--space-16);
            border-radius: 20px;
            font-weight: 600;
            margin-bottom: var(--space-12);
            font-size: var(--font-size-base);
        }

        .badge.real {
            background: var(--color-success);
            color: white;
        }

        .badge.fake {
            background: var(--color-error);
            color: white;
        }

        .confidence {
            font-size: var(--font-size-lg);
            font-weight: 600;
            margin: var(--space-12) 0;
        }

        .features-list {
            text-align: left;
            background: rgba(0, 0, 0, 0.02);
            border-radius: var(--radius-base);
            padding: var(--space-12);
            margin-top: var(--space-12);
            font-size: 13px;
        }

        .features-list li {
            margin: var(--space-4) 0;
            color: var(--color-text-secondary);
        }

        .grok-section {
            background: var(--color-surface);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: var(--space-20);
            margin-bottom: var(--space-24);
        }

        .grok-section h3 {
            margin: 0 0 var(--space-12) 0;
            font-size: var(--font-size-lg);
            color: var(--color-text);
        }

        .grok-explanation {
            background: white;
            border-left: 4px solid var(--color-primary);
            padding: var(--space-16);
            border-radius: var(--radius-base);
            line-height: 1.6;
            color: var(--color-text);
            font-size: var(--font-size-base);
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .loading {
            display: inline-block;
            color: var(--color-primary);
        }

        .loading::after {
            content: '...';
            animation: dots 1.5s steps(4, end) infinite;
        }

        @keyframes dots {
            0%, 20% { content: '.'; }
            40% { content: '..'; }
            60% { content: '...'; }
        }

        .button {
            padding: var(--space-12) var(--space-20);
            background: var(--color-primary);
            color: white;
            border: none;
            border-radius: var(--radius-base);
            font-size: var(--font-size-base);
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
        }

        .button:hover:not(:disabled) {
            background: var(--color-primary-hover);
        }

        .button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .error {
            background: rgba(255, 84, 89, 0.1);
            border: 1px solid var(--color-error);
            color: var(--color-error);
            padding: var(--space-12);
            border-radius: var(--radius-base);
            margin-bottom: var(--space-16);
        }

        @media (max-width: 768px) {
            body {
                padding: var(--space-12);
            }

            .upload-section,
            .grid-2x2,
            .classification-result {
                grid-template-columns: 1fr;
            }

            .api-input-group {
                flex-direction: column;
            }

            h1 {
                font-size: var(--font-size-2xl);
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üõ∞Ô∏è Satellite Real vs AI Image Detector</h1>
            <p class="subtitle">Detect synthetic satellite imagery using PCA sensor artifact analysis + Grok AI reasoning</p>
        </header>

        <div class="api-setup">
            <h3 style="margin-top: 0;">API Configuration</h3>
            <div class="api-input-group">
                <input type="password" id="grokApiKey" placeholder="Enter Grok API Key (get from api.x.ai)" />
                <button class="button" onclick="testApiKey()">Test API</button>
            </div>
            <p style="font-size: 12px; color: var(--color-text-secondary); margin: 0;">
                Free from xAI: <a href="https://console.x.ai/" target="_blank" style="color: var(--color-primary);">Get API Key</a>
            </p>
        </div>

        <div id="errorContainer"></div>

        <div class="upload-section">
            <div class="upload-card">
                <h3>üì° Reference Image</h3>
                <p>Upload any image as reference</p>
                <div class="file-input-wrapper">
                    <input type="file" id="realImageInput" accept="image/*" />
                    <label for="realImageInput" class="file-input-label">Choose Reference Image</label>
                </div>
                <img id="realImagePreview" class="preview-image" style="display: none;" />
                <div id="realImageStatus" style="margin-top: var(--space-12); color: var(--color-text-secondary);"></div>
            </div>

            <div class="upload-card">
                <h3>üîç Test Image</h3>
                <p>Upload image to analyze (real or AI)</p>
                <div class="file-input-wrapper">
                    <input type="file" id="testImageInput" accept="image/*" />
                    <label for="testImageInput" class="file-input-label">Choose Test Image</label>
                </div>
                <img id="testImagePreview" class="preview-image" style="display: none;" />
                <div id="testImageStatus" style="margin-top: var(--space-12); color: var(--color-text-secondary);"></div>
            </div>
        </div>

        <div style="text-align: center; margin-bottom: var(--space-24);">
            <button class="button" onclick="analyzeImages()" id="analyzeButton" disabled>Analyze Images</button>
        </div>

        <div id="resultsContainer" class="results-section">
            <div class="grid-2x2">
                <div class="grid-item">
                    <div class="row-label">Original Images</div>
                    <div style="margin-bottom: var(--space-16);">
                        <h4 style="margin: 0 0 var(--space-8) 0;">Reference</h4>
                        <canvas id="realCanvas" width="300" height="300"></canvas>
                    </div>
                    <div>
                        <h4 style="margin: 0 0 var(--space-8) 0;">Test</h4>
                        <canvas id="testCanvas" width="300" height="300"></canvas>
                    </div>
                </div>

                <div class="grid-item">
                    <div class="row-label">First 2 PCA Components</div>
                    <div style="margin-bottom: var(--space-16);">
                        <h4 style="margin: 0 0 var(--space-8) 0;">Reference (PC1 vs PC2)</h4>
                        <canvas id="realPCACanvas" width="300" height="300"></canvas>
                    </div>
                    <div>
                        <h4 style="margin: 0 0 var(--space-8) 0;">Test (PC1 vs PC2)</h4>
                        <canvas id="testPCACanvas" width="300" height="300"></canvas>
                    </div>
                </div>
            </div>

            <div class="classification-box">
                <h3>Classification Result</h3>
                <div class="classification-result">
                    <div class="result-card real">
                        <div class="badge real">REAL</div>
                        <div style="font-size: var(--font-size-base); color: var(--color-text-secondary);">Confidence:</div>
                        <div id="realConfidence" class="confidence">-</div>
                        <ul class="features-list" id="realFeatures"></ul>
                    </div>
                    <div class="result-card fake">
                        <div class="badge fake">AI GENERATED</div>
                        <div style="font-size: var(--font-size-base); color: var(--color-text-secondary);">Confidence:</div>
                        <div id="fakeConfidence" class="confidence">-</div>
                        <ul class="features-list" id="fakeFeatures"></ul>
                    </div>
                </div>
                <p id="classification" style="margin-top: var(--space-20); font-size: var(--font-size-lg); font-weight: 600; text-align: center;"></p>
            </div>

            <div class="grok-section">
                <h3>üß† Grok Security Analysis</h3>
                <button class="button" onclick="getGrokExplanation()" id="grokButton" disabled style="margin-bottom: var(--space-16);">Get Grok Explanation</button>
                <div id="grokExplanation" class="grok-explanation" style="display: none;"></div>
                <div id="grokLoading" style="display: none; padding: var(--space-16);" class="loading">Grok is analyzing</div>
            </div>
        </div>
    </div>

    <script>
        let realImageData = null;
        let testImageData = null;
        let realPCAData = null;
        let testPCAData = null;

        // File inputs
        document.getElementById('realImageInput').addEventListener('change', (e) => loadImage(e, 'real'));
        document.getElementById('testImageInput').addEventListener('change', (e) => loadImage(e, 'test'));

        function loadImage(event, type) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = 300;
                    canvas.height = 300;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0, 300, 300);

                    const imageData = ctx.getImageData(0, 0, 300, 300);
                    if (type === 'real') {
                        realImageData = imageData;
                        document.getElementById('realImagePreview').src = e.target.result;
                        document.getElementById('realImagePreview').style.display = 'block';
                        document.getElementById('realImageStatus').textContent = '‚úì Loaded';
                    } else {
                        testImageData = imageData;
                        document.getElementById('testImagePreview').src = e.target.result;
                        document.getElementById('testImagePreview').style.display = 'block';
                        document.getElementById('testImageStatus').textContent = '‚úì Loaded';
                    }

                    updateAnalyzeButton();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function updateAnalyzeButton() {
            const button = document.getElementById('analyzeButton');
            button.disabled = !realImageData || !testImageData;
        }

        function testApiKey() {
            const key = document.getElementById('grokApiKey').value;
            if (!key) {
                showError('Please enter Grok API Key');
                return;
            }
            showError('‚úì API Key saved. You can now get Grok explanations.');
        }

        function showError(message) {
            const container = document.getElementById('errorContainer');
            container.innerHTML = `<div class="error">${message}</div>`;
            setTimeout(() => { container.innerHTML = ''; }, 5000);
        }

        // PCA Implementation
        function imageToPatchVectors(imageData, patchSize = 8) {
            const data = imageData.data;
            const width = imageData.width;
            const height = imageData.height;

            // Convert to grayscale
            const gray = [];
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                gray.push(0.299 * r + 0.587 * g + 0.114 * b);
            }

            // Extract patches
            const patches = [];
            for (let y = 0; y < height - patchSize; y += patchSize) {
                for (let x = 0; x < width - patchSize; x += patchSize) {
                    const patch = [];
                    for (let py = 0; py < patchSize; py++) {
                        for (let px = 0; px < patchSize; px++) {
                            const idx = (y + py) * width + (x + px);
                            patch.push(gray[idx]);
                        }
                    }
                    patches.push(patch);
                }
            }
            return patches;
        }

        function performPCA(vectors) {
            if (vectors.length === 0) return { components: [], explained_variance: [] };

            const numVectors = vectors.length;
            const vectorDim = vectors[0].length;

            // Mean center
            const mean = Array(vectorDim).fill(0);
            for (const v of vectors) {
                for (let i = 0; i < vectorDim; i++) mean[i] += v[i];
            }
            for (let i = 0; i < vectorDim; i++) mean[i] /= numVectors;

            const centered = vectors.map(v => v.map((val, i) => val - mean[i]));

            // Covariance matrix (simplified: use sample covariance)
            const cov = Array(vectorDim).fill(0).map(() => Array(vectorDim).fill(0));
            for (const v of centered) {
                for (let i = 0; i < vectorDim; i++) {
                    for (let j = i; j < vectorDim; j++) {
                        cov[i][j] += v[i] * v[j];
                    }
                }
            }
            for (let i = 0; i < vectorDim; i++) {
                for (let j = i; j < vectorDim; j++) {
                    cov[i][j] /= numVectors;
                    cov[j][i] = cov[i][j];
                }
            }

            // Power iteration for largest eigenvalue/eigenvector
            const getEigenvector = (matrix, numIter = 20) => {
                let v = Array(vectorDim).fill(1).map(() => Math.random());
                const norm = (arr) => Math.sqrt(arr.reduce((a, b) => a + b * b, 0));
                v = v.map(x => x / norm(v));

                for (let iter = 0; iter < numIter; iter++) {
                    const Av = Array(vectorDim).fill(0);
                    for (let i = 0; i < vectorDim; i++) {
                        for (let j = 0; j < vectorDim; j++) {
                            Av[i] += matrix[i][j] * v[j];
                        }
                    }
                    const normAv = norm(Av);
                    v = Av.map(x => x / normAv);
                }
                return v;
            };

            // Extract first 2 components
            const components = [];
            let residualCov = cov.map(row => [...row]);

            for (let comp = 0; comp < 2; comp++) {
                const eigvec = getEigenvector(residualCov);
                components.push(eigvec);

                // Deflate
                const lambda = 0.1; // Simplified eigenvalue
                for (let i = 0; i < vectorDim; i++) {
                    for (let j = 0; j < vectorDim; j++) {
                        residualCov[i][j] -= lambda * eigvec[i] * eigvec[j];
                    }
                }
            }

            return { components, mean, centered };
        }

        function computeFeatures(imageData) {
            const patches = imageToPatchVectors(imageData, 8);
            const pca = performPCA(patches);

            if (pca.components.length < 2) {
                return {
                    pc1_variance: 0,
                    pc2_variance: 0,
                    coherence: 0,
                    noise_level: 0
                };
            }

            // Project onto first 2 components
            const pc1_proj = [];
            const pc2_proj = [];
            for (const v of pca.centered) {
                let p1 = 0, p2 = 0;
                for (let i = 0; i < v.length; i++) {
                    p1 += v[i] * pca.components[0][i];
                    p2 += v[i] * pca.components[1][i];
                }
                pc1_proj.push(p1);
                pc2_proj.push(p2);
            }

            // Variance in first components
            const variance = (arr) => {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
            };

            const pc1_var = variance(pc1_proj);
            const pc2_var = variance(pc2_proj);

            // Coherence (spatial autocorrelation)
            const coherence = pc1_var > 0 ? Math.min(pc2_var / pc1_var, 1) : 0;

            // Noise level (high-freq component)
            const data = imageData.data;
            let noiseEnergy = 0;
            for (let i = 0; i < data.length - 4; i += 4) {
                const r = data[i];
                const r_next = data[i + 4];
                noiseEnergy += Math.abs(r - r_next);
            }
            const noise_level = noiseEnergy / (data.length / 4);

            return {
                pc1_variance: pc1_var,
                pc2_variance: pc2_var,
                coherence,
                noise_level,
                pca_components: pca.components,
                pca_projection: { pc1: pc1_proj, pc2: pc2_proj }
            };
        }

        function visualizePCAComponents(pca_proj, canvasId) {
            const canvas = document.getElementById(canvasId);
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            if (!pca_proj || !pca_proj.pc1 || !pca_proj.pc2) return;

            const pc1 = pca_proj.pc1;
            const pc2 = pca_proj.pc2;
            const padding = 40;
            const plotWidth = canvas.width - 2 * padding;
            const plotHeight = canvas.height - 2 * padding;

            // Normalize
            const min1 = Math.min(...pc1);
            const max1 = Math.max(...pc1);
            const min2 = Math.min(...pc2);
            const max2 = Math.max(...pc2);

            // Draw axes
            ctx.strokeStyle = '#ccc';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(padding, padding + plotHeight / 2);
            ctx.lineTo(padding + plotWidth, padding + plotHeight / 2);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(padding + plotWidth / 2, padding);
            ctx.lineTo(padding + plotWidth / 2, padding + plotHeight);
            ctx.stroke();

            // Draw points
            ctx.fillStyle = 'rgba(33, 128, 141, 0.6)';
            for (let i = 0; i < pc1.length; i++) {
                const x = padding + ((pc1[i] - min1) / (max1 - min1 || 1)) * plotWidth;
                const y = padding + plotHeight - ((pc2[i] - min2) / (max2 - min2 || 1)) * plotHeight;
                ctx.beginPath();
                ctx.arc(x, y, 2, 0, 2 * Math.PI);
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('PC1 ‚Üí', canvas.width - 20, padding - 10);
            ctx.save();
            ctx.translate(10, canvas.height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('‚Üê PC2', 0, 0);
            ctx.restore();
        }

        function analyzeImages() {
            if (!realImageData || !testImageData) {
                showError('Please load both images');
                return;
            }

            // Draw original images
            const realCtx = document.getElementById('realCanvas').getContext('2d');
            realCtx.putImageData(realImageData, 0, 0);

            const testCtx = document.getElementById('testCanvas').getContext('2d');
            testCtx.putImageData(testImageData, 0, 0);

            // Compute PCA features
            realPCAData = computeFeatures(realImageData);
            testPCAData = computeFeatures(testImageData);

            // Visualize PCA
            visualizePCAComponents(realPCAData.pca_projection, 'realPCACanvas');
            visualizePCAComponents(testPCAData.pca_projection, 'testPCACanvas');

            // Classify
            const realCoherence = realPCAData.coherence || 0;
            const testCoherence = testPCAData.coherence || 0;
            const realNoise = realPCAData.noise_level || 0;
            const testNoise = testPCAData.noise_level || 0;

            // Simple classifier: real images have higher coherence + moderate noise
            const testScore = (testCoherence * 0.6 + (1 - Math.abs(testNoise - realNoise) / (realNoise || 1)) * 0.4);
            const isReal = testScore > 0.5;

            const realConf = Math.min(100, Math.round(realCoherence * 100));
            const fakeConf = Math.min(100, Math.round((1 - testCoherence) * 100));

            document.getElementById('realConfidence').textContent = realConf + '%';
            document.getElementById('fakeConfidence').textContent = fakeConf + '%';

            document.getElementById('realFeatures').innerHTML = `
                <li>Coherence: ${realCoherence.toFixed(3)}</li>
                <li>Noise Level: ${realNoise.toFixed(2)}</li>
                <li>PC1 Variance: ${realPCAData.pc1_variance.toFixed(2)}</li>
            `;

            document.getElementById('fakeFeatures').innerHTML = `
                <li>Coherence: ${testCoherence.toFixed(3)}</li>
                <li>Noise Level: ${testNoise.toFixed(2)}</li>
                <li>PC1 Variance: ${testPCAData.pc1_variance.toFixed(2)}</li>
            `;

            const classificationText = isReal 
                ? `‚úì Test image appears <strong>REAL</strong> (${realConf}% confidence). PCA components show coherent structure.`
                : `‚ö† Test image appears <strong>AI-GENERATED</strong> (${fakeConf}% confidence). PCA components show scattered structure.`;

            document.getElementById('classification').innerHTML = classificationText;
            document.getElementById('resultsContainer').classList.add('active');
            document.getElementById('grokButton').disabled = false;
        }

        async function getGrokExplanation() {
            const apiKey = document.getElementById('grokApiKey').value;
            if (!apiKey) {
                showError('Please set Grok API Key first');
                return;
            }

            document.getElementById('grokButton').disabled = true;
            document.getElementById('grokLoading').style.display = 'block';
            document.getElementById('grokExplanation').style.display = 'none';

            try {
                // Convert images to base64
                const canvas = document.createElement('canvas');
                canvas.width = 300;
                canvas.height = 300;
                const ctx = canvas.getContext('2d');

                ctx.putImageData(realImageData, 0, 0);
                const realB64 = canvas.toDataURL('image/jpeg').split(',')[1];

                ctx.putImageData(testImageData, 0, 0);
                const testB64 = canvas.toDataURL('image/jpeg').split(',')[1];

                const prompt = `You are an image forensics expert. Analyze these two images and provide a brief assessment (3-4 sentences) on whether the second image appears real or AI-generated based on its visual characteristics. Consider sensor artifacts, noise patterns, texture consistency, and spatial coherence.

PCA Analysis Metrics:
Reference Image - Coherence: ${realPCAData.coherence.toFixed(3)}, Noise: ${realPCAData.noise_level.toFixed(2)}
Test Image - Coherence: ${testPCAData.coherence.toFixed(3)}, Noise: ${testPCAData.noise_level.toFixed(2)}

Key insight: Real images show coherent PCA components with structured noise. AI images show scattered components with broken correlations.`;

                const response = await fetch('https://api.x.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'grok-vision-beta',
                        messages: [
                            {
                                role: 'user',
                                content: [
                                    {
                                        type: 'text',
                                        text: prompt
                                    },
                                    {
                                        type: 'image',
                                        image: {
                                            format: 'jpeg',
                                            data: realB64
                                        }
                                    },
                                    {
                                        type: 'image',
                                        image: {
                                            format: 'jpeg',
                                            data: testB64
                                        }
                                    }
                                ]
                            }
                        ],
                        temperature: 0.3,
                        max_tokens: 500
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error?.message || 'API Error');
                }

                const data = await response.json();
                const explanation = data.choices[0].message.content;
                document.getElementById('grokExplanation').textContent = explanation;
                document.getElementById('grokExplanation').style.display = 'block';
            } catch (err) {
                showError('Grok API Error: ' + err.message);
            } finally {
                document.getElementById('grokLoading').style.display = 'none';
                document.getElementById('grokButton').disabled = false;
            }
        }
    </script>
</body>
</html>
